<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Procedural City - A-Frame</title>
    <style>
        body, html { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; }
        #ar-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            width: 300px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 10;
            display: none; /* Hidden until marker is found */
        }
        h1 {
            margin-top: 0;
            font-size: 1.5em;
            color: #f3f4f6;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        button {
            background: linear-gradient(45deg, #f97316, #ea580c);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(249, 115, 22, 0.4);
            margin-bottom: 10px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.5);
        }
        .secondary-button {
             background: linear-gradient(45deg, #3b82f6, #2563eb);
             box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        .secondary-button:hover {
             box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }
        .input-group { margin-top: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 0.9em; color: #d1d5db; }
        input[type="number"] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(31, 41, 55, 0.8);
            color: #fff;
            font-size: 1em;
            box-sizing: border-box;
        }
        /* Hide the default A-Frame canvas styling */
        .a-canvas {
            position: absolute !important;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- A-Frame and AR.js Libraries -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <!-- Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>
    <div id="ar-container">
        <!-- UI Panel -->
        <div id="ui-panel">
            <h1>Procedural City AR</h1>
            <button id="generate-btn">Generate New City</button>
            <button id="drop-casa-cubes-btn" class="secondary-button">Drop CASA Cubes</button>
            <div class="input-group">
                <label for="cube-count">Number of Cubes:</label>
                <input type="number" id="cube-count" value="64" min="1" max="100">
            </div>
        </div>

        <!-- A-Frame Scene -->
        <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;' renderer="colorManagement: true;">
            
            <!-- Lighting -->
            <a-light type="ambient" color="#CCC" intensity="1.5"></a-light>
            <a-light type="directional" color="#FFF" intensity="2.0" position="-1 1 0.5"></a-light>

            <!-- Custom Image Marker -->
            <a-marker type='pattern' url='https://raw.githack.com/digitalurban/VibeABM/main/images/casa_logo.jpg' id='casa-marker'>
                <!-- Entity that will hold the procedural city -->
                <a-entity
                    id="city-container"
                    procedural-city
                    scale="0.1 0.1 0.1"
                    position="0 -0.5 0">
                </a-entity>
            </a-marker>

            <!-- Camera -->
            <a-entity camera></a-entity>
        </a-scene>
    </div>

    <script>
    AFRAME.registerComponent('procedural-city', {
        init: function () {
            // --- Component Scope Variables ---
            const el = this.el; // The <a-entity> this component is attached to
            this.world = null;
            this.clock = new THREE.Clock();
            
            this.cityGroup = el.object3D; // Use the entity's Object3D as the main group
            this.trafficGroup = new THREE.Group();
            this.pedestrianGroup = new THREE.Group();
            this.cloudsGroup = new THREE.Group();
            this.birdsGroup = new THREE.Group();
            
            this.cars = [];
            this.trafficLights = [];
            this.pedestrians = [];
            this.physicsObjects = [];
            this.clouds = [];
            this.boids = [];

            // --- City Configuration ---
            this.citySize = 10;
            this.blockSize = 20;
            this.roadWidth = 8;
            this.totalBlockSize = this.blockSize + this.roadWidth;
            this.cityOffset = - (this.citySize * this.totalBlockSize) / 2;

            // --- Materials ---
            this.roadMat = new THREE.MeshLambertMaterial({ color: 0x34495e });
            this.yellowLineMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
            this.whiteLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            this.pavementMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
            this.curbMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });
            this.cloudMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, transparent: true, opacity: 0.8 });
            this.birdMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.8 });
            const logoTexture = new THREE.TextureLoader().load('https://digitalurban.github.io/VibeABM/images/casa_logo.jpg');
            logoTexture.anisotropy = 16;
            this.cubeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, map: logoTexture, metalness: 0.1, roughness: 0.8 });
            this.greenLightOnMat = new THREE.MeshStandardMaterial({ emissive: '#2ecc71', emissiveIntensity: 2 });
            this.greenLightOffMat = new THREE.MeshStandardMaterial({ color: '#2ecc71', emissiveIntensity: 0.1 });
            this.redLightOnMat = new THREE.MeshStandardMaterial({ emissive: '#e74c3c', emissiveIntensity: 2 });
            this.redLightOffMat = new THREE.MeshStandardMaterial({ color: '#e74c3c', emissiveIntensity: 0.1 });

            // --- Physics Materials ---
            this.worldPhysicsMaterial = new CANNON.Material('world');
            this.cubePhysicsMaterial = new CANNON.Material('cube');
            this.cubeWorldContactMaterial = new CANNON.ContactMaterial(this.worldPhysicsMaterial, this.cubePhysicsMaterial, { friction: 0.1, restitution: 0.9 });

            // --- BOIDS CONFIGURATION ---
            this.BOID_COUNT = 80;
            this.BOID_BOUNDS = this.citySize * this.totalBlockSize / 2;
            this.MAX_SPEED = 0.5;
            this.MAX_FORCE = 0.03;
            this.PERCEPTION_RADIUS = 20;

            // --- Physics World Setup ---
            this.world = new CANNON.World();
            this.world.gravity.set(0, -9.82, 0);
            this.world.broadphase = new CANNON.NaiveBroadphase();
            this.world.solver.iterations = 10;
            this.world.addContactMaterial(this.cubeWorldContactMaterial);

            // --- Add initial groups ---
            this.cityGroup.add(this.trafficGroup, this.pedestrianGroup, this.cloudsGroup, this.birdsGroup);

            // --- Generate the city ---
            this.generateCity();

            // --- Bind `this` for methods and event listeners ---
            this.generateCity = this.generateCity.bind(this);
            this.dropCASA_Cubes = this.dropCASA_Cubes.bind(this);

            // --- UI Event Listeners ---
            document.getElementById('generate-btn').addEventListener('click', this.generateCity);
            document.getElementById('drop-casa-cubes-btn').addEventListener('click', this.dropCASA_Cubes);

            const marker = document.querySelector('#casa-marker');
            const uiPanel = document.querySelector('#ui-panel');
            marker.addEventListener('markerFound', () => {
                uiPanel.style.display = 'block';
            });
            marker.addEventListener('markerLost', () => {
                uiPanel.style.display = 'none';
            });
        },

        tick: function (time, timeDelta) {
            // The tick function is the animation loop in A-Frame
            const deltaTime = this.clock.getDelta();
            
            // Only run simulations if the marker is visible
            if (!this.el.object3D.visible) {
                return;
            }

            this.world.step(1/60, deltaTime, 3);
            this.physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            this.updateTrafficLights(deltaTime);
            this.animateTraffic();
            this.animatePedestrians();
            this.animateClouds();
            this.animateBoids();
        },

        // --- All city generation and animation functions are now methods of the component ---
        
        clearSceneGroup: function(group) {
            while(group.children.length > 0) {
                const object = group.children[0];
                if(object.geometry) object.geometry.dispose();
                if(object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(m => m.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
                group.remove(object);
            }
        },

        generateCity: function() {
            this.cityGroup.remove(this.trafficGroup, this.pedestrianGroup, this.cloudsGroup, this.birdsGroup);
            this.clearSceneGroup(this.trafficGroup);
            this.clearSceneGroup(this.pedestrianGroup);
            this.clearSceneGroup(this.cloudsGroup);
            this.clearSceneGroup(this.birdsGroup);
            this.physicsObjects.forEach(obj => {
                this.cityGroup.remove(obj.mesh);
                if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                this.world.removeBody(obj.body);
            });
            this.physicsObjects = [];
            while(this.world.bodies.length > 0){ this.world.removeBody(this.world.bodies[0]); }
            this.cars = []; this.trafficLights = []; this.pedestrians = []; this.clouds = []; this.boids = [];
            this.cityGroup.add(this.trafficGroup, this.pedestrianGroup, this.cloudsGroup, this.birdsGroup);
            const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: this.worldPhysicsMaterial });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            this.world.addBody(groundBody);
            for (let i = 0; i <= this.citySize; i++) {
                for (let j = 0; j <= this.citySize; j++) {
                    const x = this.cityOffset + i * this.totalBlockSize;
                    const z = this.cityOffset + j * this.totalBlockSize;
                    if (i < this.citySize && j < this.citySize) this.createCityBlock(x, z, i, j);
                    if (i < this.citySize) this.createRoadSegment(new THREE.Vector3(x - this.roadWidth/2, 0.01, z + this.blockSize/2), false, this.blockSize);
                    if (j < this.citySize) this.createRoadSegment(new THREE.Vector3(x + this.blockSize/2, 0.01, z - this.roadWidth/2), true, this.blockSize);
                    if (i < this.citySize && j < this.citySize) this.createIntersection(x, z, i, j);
                }
            }
            this.generateTraffic();
            this.generatePedestrians();
            this.generateClouds();
            this.generateBoids();
        },

        createCityBlock: function(x, z, gridI, gridJ) {
            const pavementGeo = new THREE.BoxGeometry(this.blockSize, 0.2, this.blockSize);
            const pavement = new THREE.Mesh(pavementGeo, this.pavementMat);
            pavement.position.set(x + this.blockSize/2, 0.1, z + this.blockSize/2);
            pavement.receiveShadow = true;
            this.cityGroup.add(pavement);
            const curbGeo = new THREE.BoxGeometry(this.blockSize + 0.2, 0.25, this.blockSize + 0.2);
            const curb = new THREE.Mesh(curbGeo, this.curbMat);
            curb.position.set(x + this.blockSize/2, 0.08, z + this.blockSize/2);
            curb.receiveShadow = true;
            this.cityGroup.add(curb);
            const buildingCount = Math.floor(2 + Math.random() * 4);
            for(let i = 0; i < buildingCount; i++) { this.createBuilding(x + (Math.random() * (this.blockSize - 6)) + 3, z + (Math.random() * (this.blockSize - 6)) + 3); }
            const treeCount = Math.floor(3 + Math.random() * 5);
            for(let i = 0; i < treeCount; i++) { this.createTree(x + (Math.random() * (this.blockSize - 2)) + 1, z + (Math.random() * (this.blockSize - 2)) + 1, 0.2); }
        },

        createBuilding: function(x, z) {
            const height = 10 + Math.random() * 30;
            const width = 5;
            const depth = 5;
            const buildingGeo = new THREE.BoxGeometry(width, height, depth);
            const buildingMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(0.7,0.7,0.7).multiplyScalar(0.8 + Math.random()*0.2) });
            const building = new THREE.Mesh(buildingGeo, buildingMat);
            building.position.set(x, height/2 + 0.2, z);
            building.castShadow = true;
            this.cityGroup.add(building);
            const buildingShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const buildingBody = new CANNON.Body({ mass: 0, shape: buildingShape, material: this.worldPhysicsMaterial });
            buildingBody.position.set(x, height/2 + 0.2, z);
            this.world.addBody(buildingBody);
        },

        dropCASA_Cubes: function() {
            const countInput = document.getElementById('cube-count');
            const count = parseInt(countInput.value);
            if (isNaN(count) || count <= 0) return;
            const gridDim = Math.ceil(Math.sqrt(count));
            const cityWidth = this.citySize * this.totalBlockSize;
            const spacing = cityWidth / (gridDim + 1);
            let droppedCount = 0;
            for (let i = 0; i < gridDim; i++) {
                for (let j = 0; j < gridDim; j++) {
                    if (droppedCount >= count) break;
                    const cubeWidth = 4; const cubeHeight = 5; const cubeDepth = 4;
                    const cubeGeo = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
                    const cubeMesh = new THREE.Mesh(cubeGeo, this.cubeMat);
                    cubeMesh.castShadow = true;
                    const cubeShape = new CANNON.Box(new CANNON.Vec3(cubeWidth/2, cubeHeight/2, cubeDepth/2));
                    const cubeBody = new CANNON.Body({ mass: 5, shape: cubeShape, material: this.cubePhysicsMaterial });
                    const x = this.cityOffset + (i + 1) * spacing;
                    const z = this.cityOffset + (j + 1) * spacing;
                    cubeBody.position.set(x, 150, z);
                    cubeMesh.position.copy(cubeBody.position);
                    this.world.addBody(cubeBody);
                    this.cityGroup.add(cubeMesh); 
                    this.physicsObjects.push({ mesh: cubeMesh, body: cubeBody });
                    droppedCount++;
                }
                if (droppedCount >= count) break;
            }
        },

        createCloud: function() { const cloud = new THREE.Group(); const puffGeo = new THREE.SphereGeometry(5, 4, 4); for (let i = 0; i < 5 + Math.random() * 5; i++) { const puff = new THREE.Mesh(puffGeo, this.cloudMat); puff.position.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 10); puff.scale.setScalar(0.8 + Math.random() * 0.4); cloud.add(puff); } cloud.castShadow = true; return cloud; },
        generateClouds: function() { const numClouds = 25; const cityWidth = this.citySize * this.totalBlockSize; for (let i = 0; i < numClouds; i++) { const cloudMesh = this.createCloud(); cloudMesh.position.set((Math.random() - 0.5) * cityWidth * 2, 100 + Math.random() * 20, (Math.random() - 0.5) * cityWidth * 2); this.clouds.push({ mesh: cloudMesh, speed: 0.02 + Math.random() * 0.03 }); this.cloudsGroup.add(cloudMesh); } },
        generateBoids: function() { for (let i = 0; i < this.BOID_COUNT; i++) { this.boids.push(this.createBoid()); } },
        createBoid: function() {
            const boid = {
                position: new THREE.Vector3((Math.random() - 0.5) * this.BOID_BOUNDS, 60 + Math.random() * 40, (Math.random() - 0.5) * this.BOID_BOUNDS),
                velocity: new THREE.Vector3().randomDirection().multiplyScalar(Math.random() * this.MAX_SPEED),
                acceleration: new THREE.Vector3(),
                mesh: new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.2, 4), this.birdMat)
            };
            boid.mesh.position.copy(boid.position);
            this.birdsGroup.add(boid.mesh);
            return boid;
        },
        animateBoids: function() { for (let boid of this.boids) { this.flock(boid, this.boids); this.updateBoid(boid); } },
        flock: function(boid, boids) {
            boid.acceleration.set(0, 0, 0);
            const alignment = this.alignment(boid, boids);
            const cohesion = this.cohesion(boid, boids);
            const separation = this.separation(boid, boids);
            const bounds = this.bounds(boid);
            boid.acceleration.add(alignment.multiplyScalar(1.0));
            boid.acceleration.add(cohesion.multiplyScalar(1.0));
            boid.acceleration.add(separation.multiplyScalar(1.5));
            boid.acceleration.add(bounds.multiplyScalar(2.0));
        },
        updateBoid: function(boid) {
            boid.velocity.add(boid.acceleration);
            boid.velocity.clampLength(0, this.MAX_SPEED);
            boid.position.add(boid.velocity);
            boid.mesh.position.copy(boid.position);
            boid.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), boid.velocity.clone().normalize());
        },
        separation: function(boid, boids) { let steering = new THREE.Vector3(); let total = 0; for (let other of boids) { let d = boid.position.distanceTo(other.position); if (other !== boid && d < this.PERCEPTION_RADIUS / 2) { let diff = new THREE.Vector3().subVectors(boid.position, other.position); diff.divideScalar(d * d); steering.add(diff); total++; } } if (total > 0) { steering.divideScalar(total); steering.setLength(this.MAX_SPEED); steering.sub(boid.velocity); steering.clampLength(0, this.MAX_FORCE); } return steering; },
        alignment: function(boid, boids) { let steering = new THREE.Vector3(); let total = 0; for (let other of boids) { let d = boid.position.distanceTo(other.position); if (other !== boid && d < this.PERCEPTION_RADIUS) { steering.add(other.velocity); total++; } } if (total > 0) { steering.divideScalar(total); steering.setLength(this.MAX_SPEED); steering.sub(boid.velocity); steering.clampLength(0, this.MAX_FORCE); } return steering; },
        cohesion: function(boid, boids) { let steering = new THREE.Vector3(); let total = 0; for (let other of boids) { let d = boid.position.distanceTo(other.position); if (other !== boid && d < this.PERCEPTION_RADIUS) { steering.add(other.position); total++; } } if (total > 0) { steering.divideScalar(total); steering.sub(boid.position); steering.setLength(this.MAX_SPEED); steering.sub(boid.velocity); steering.clampLength(0, this.MAX_FORCE); } return steering; },
        bounds: function(boid) { const turnForce = 0.1; let steering = new THREE.Vector3(); if (boid.position.x > this.BOID_BOUNDS) steering.x = -turnForce; else if (boid.position.x < -this.BOID_BOUNDS) steering.x = turnForce; if (boid.position.y > 120) steering.y = -turnForce; else if (boid.position.y < 40) steering.y = turnForce; if (boid.position.z > this.BOID_BOUNDS) steering.z = -turnForce; else if (boid.position.z < -this.BOID_BOUNDS) steering.z = turnForce; return steering; },
        generatePedestrians: function() { const numPedestrians = 150; for (let i = 0; i < numPedestrians; i++) { const pedestrian = this.createPedestrian(); const startBlockI = Math.floor(Math.random() * this.citySize); const startBlockJ = Math.floor(Math.random() * this.citySize); const p = { mesh: pedestrian, speed: 0.03 + Math.random() * 0.02, target: new THREE.Vector3(), block: { i: startBlockI, j: startBlockJ } }; const startPos = this.getNewTargetOnBlock(p.block); pedestrian.position.copy(startPos); this.setNewPedestrianTarget(p); this.pedestrians.push(p); this.pedestrianGroup.add(pedestrian); } },
        createPedestrian: function() { const personColors = [0x3498db, 0x9b59b6, 0x1abc9c, 0xf39c12]; const personMat = new THREE.MeshStandardMaterial({ color: personColors[Math.floor(Math.random() * personColors.length)] }); const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8); const headGeo = new THREE.SphereGeometry(0.3, 8, 8); const person = new THREE.Group(); const body = new THREE.Mesh(bodyGeo, personMat); body.position.y = 0.6; const head = new THREE.Mesh(headGeo, personMat); head.position.y = 1.5; person.add(body, head); person.castShadow = true; return person; },
        getNewTargetOnBlock: function(block) { const x = this.cityOffset + block.i * this.totalBlockSize + Math.random() * this.blockSize; const z = this.cityOffset + block.j * this.totalBlockSize + Math.random() * this.blockSize; return new THREE.Vector3(x, 0.2, z); },
        setNewPedestrianTarget: function(p) { if (Math.random() < 0.2) { const dir = Math.floor(Math.random() * 4); if (dir === 0 && p.block.i < this.citySize - 1) p.block.i++; else if (dir === 1 && p.block.i > 0) p.block.i--; else if (dir === 2 && p.block.j < this.citySize - 1) p.block.j++; else if (dir === 3 && p.block.j > 0) p.block.j--; } p.target.copy(this.getNewTargetOnBlock(p.block)); },
        animatePedestrians: function() { this.pedestrians.forEach(p => { const pos = p.mesh.position; if (pos.distanceTo(p.target) < 1) { this.setNewPedestrianTarget(p); } else { const direction = p.target.clone().sub(pos).normalize(); pos.x += direction.x * p.speed; pos.z += direction.z * p.speed; p.mesh.lookAt(p.target); } }); },
        animateClouds: function() { const cityLimit = this.citySize * this.totalBlockSize; this.clouds.forEach(cloudObj => { cloudObj.mesh.position.x += cloudObj.speed; if (cloudObj.mesh.position.x > cityLimit) { cloudObj.mesh.position.x = -cityLimit; } }); },
        createRoadSegment: function(position, isHorizontal, length) { const roadSize = isHorizontal ? new THREE.Vector2(length, this.roadWidth) : new THREE.Vector2(this.roadWidth, length); const road = new THREE.Mesh(new THREE.PlaneGeometry(roadSize.x, roadSize.y), this.roadMat); road.rotation.x = -Math.PI / 2; road.position.copy(position); road.receiveShadow = true; this.cityGroup.add(road); const lineLength = 1.5; const lineGap = 1.5; const segmentLength = lineLength + lineGap; const lineGeo = new THREE.PlaneGeometry(isHorizontal ? lineLength : 0.1, isHorizontal ? 0.1 : lineLength); const numLines = Math.floor(length / segmentLength); for (let i = 0; i < numLines; i++) { const line = new THREE.Mesh(lineGeo, this.yellowLineMat); line.rotation.x = -Math.PI / 2; const offset = -length / 2 + segmentLength * i + lineLength / 2; if (isHorizontal) { line.position.set(position.x + offset, position.y + 0.01, position.z); } else { line.position.set(position.x, position.y + 0.01, position.z + offset); } this.cityGroup.add(line); } },
        createIntersection: function(x, z, gridI, gridJ) { const intersectionGeo = new THREE.PlaneGeometry(this.roadWidth, this.roadWidth); const intersection = new THREE.Mesh(intersectionGeo, this.roadMat); intersection.rotation.x = -Math.PI / 2; intersection.position.set(x - this.roadWidth / 2, 0.01, z - this.roadWidth / 2); this.cityGroup.add(intersection); const stopLineGeoH = new THREE.PlaneGeometry(this.roadWidth / 2, 0.2); const stopLineGeoV = new THREE.PlaneGeometry(0.2, this.roadWidth / 2); const stopLineNS = new THREE.Mesh(stopLineGeoH, this.whiteLineMat); stopLineNS.rotation.x = -Math.PI / 2; stopLineNS.position.set(x - this.roadWidth * 0.25, 0.02, z - this.roadWidth); this.cityGroup.add(stopLineNS); const stopLineEW = new THREE.Mesh(stopLineGeoV, this.whiteLineMat); stopLineEW.rotation.x = -Math.PI / 2; stopLineEW.position.set(x - this.roadWidth, 0.02, z - this.roadWidth * 0.75); this.cityGroup.add(stopLineEW); const lightController = { state: Math.random() > 0.5 ? 'NS' : 'EW', timer: Math.random() * 10, cycleTime: 8 + Math.random() * 4, lights: {} }; const lightPosOffset = this.roadWidth + 1; lightController.lights.nsRed = new THREE.Mesh(new THREE.SphereGeometry(0.3), this.redLightOffMat); lightController.lights.nsGreen = new THREE.Mesh(new THREE.SphereGeometry(0.3), this.greenLightOffMat); lightController.lights.nsRed.position.set(x - this.roadWidth * 0.75, 3.5, z - lightPosOffset); lightController.lights.nsGreen.position.set(x - this.roadWidth * 0.75, 2.8, z - lightPosOffset); lightController.lights.ewRed = new THREE.Mesh(new THREE.SphereGeometry(0.3), this.redLightOffMat); lightController.lights.ewGreen = new THREE.Mesh(new THREE.SphereGeometry(0.3), this.greenLightOffMat); lightController.lights.ewRed.position.set(x - lightPosOffset, 3.5, z - this.roadWidth * 0.25); lightController.lights.ewGreen.position.set(x - lightPosOffset, 2.8, z - this.roadWidth * 0.25); this.trafficGroup.add(lightController.lights.nsRed, lightController.lights.nsGreen, lightController.lights.ewRed, lightController.lights.ewGreen); if (!this.trafficLights[gridI]) this.trafficLights[gridI] = []; this.trafficLights[gridI][gridJ] = lightController; },
        createTree: function(x, z, y) { const trunkHeight = 2 + Math.random() * 2; const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, trunkHeight, 8); const trunkMat = new THREE.MeshStandardMaterial({ color: 0x665233 }); const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.set(x, y + trunkHeight / 2, z); trunk.castShadow = true; const foliageRadius = 1 + Math.random(); const foliageGeo = new THREE.IcosahedronGeometry(foliageRadius, 0); const foliageMat = new THREE.MeshStandardMaterial({ color: 0x27ae60, flatShading: true }); const foliage = new THREE.Mesh(foliageGeo, foliageMat); foliage.position.set(x, y + trunkHeight + foliageRadius * 0.8, z); foliage.castShadow = true; this.cityGroup.add(trunk, foliage); },
        generateTraffic: function(){ const numCars = 100; for (let i = 0; i < numCars; i++) { const car = this.createCar(); const movingAlongX = Math.random() > 0.5; const startBlock = Math.floor(Math.random() * this.citySize); const laneOffset = this.roadWidth / 4; const speed = 0.2 + Math.random() * 0.2; let carPos, carRot, direction; if (movingAlongX) { const zPos = this.cityOffset + startBlock * this.totalBlockSize - laneOffset; carPos = new THREE.Vector3(this.cityOffset - 20, 0.5, zPos); carRot = new THREE.Euler(0, Math.PI / 2, 0); direction = 'x'; } else { const xPos = this.cityOffset + startBlock * this.totalBlockSize - laneOffset; carPos = new THREE.Vector3(xPos, 0.5, this.cityOffset - 20); carRot = new THREE.Euler(0, 0, 0); direction = 'z'; } car.position.copy(carPos); car.rotation.copy(carRot); this.cars.push({ mesh: car, speed: speed, baseSpeed: speed, direction: direction }); this.trafficGroup.add(car); } },
        createCar: function(){ const carColors = [0xc0392b, 0x2980b9, 0xf1c40f, 0xecf0f1, 0x2c3e50]; const carGeo = new THREE.BoxGeometry(1.5, 1, 3); const carMat = new THREE.MeshStandardMaterial({ color: carColors[Math.floor(Math.random() * carColors.length)], metalness: 0.5, roughness: 0.5 }); const car = new THREE.Mesh(carGeo, carMat); car.castShadow = true; return car; },
        updateTrafficLights: function(deltaTime){ for (let i = 0; i < this.citySize; i++) { for (let j = 0; j < this.citySize; j++) { const light = this.trafficLights[i]?.[j]; if (!light) continue; light.timer += deltaTime; if (light.timer > light.cycleTime) { light.timer = 0; light.state = light.state === 'NS' ? 'EW' : 'NS'; } light.lights.nsGreen.material = light.state === 'NS' ? this.greenLightOnMat : this.greenLightOffMat; light.lights.nsRed.material = light.state !== 'NS' ? this.redLightOnMat : this.redLightOffMat; light.lights.ewGreen.material = light.state === 'EW' ? this.greenLightOnMat : this.greenLightOffMat; light.lights.ewRed.material = light.state !== 'EW' ? this.redLightOnMat : this.redLightOffMat; } } },
        animateTraffic: function(){ const cityLimit = this.citySize * this.totalBlockSize / 2 + 10; const safetyDistance = 5; this.cars.forEach(carObj => { const car = carObj.mesh; carObj.speed = carObj.baseSpeed; let carInFront = false; for (const otherCarObj of this.cars) { if (car === otherCarObj.mesh) continue; if (carObj.direction === otherCarObj.direction) { const pos = car.position; const otherPos = otherCarObj.mesh.position; let distance; if (carObj.direction === 'x') { if (Math.abs(pos.z - otherPos.z) < 1 && otherPos.x > pos.x) { distance = otherPos.x - pos.x; if (distance > 0 && distance < safetyDistance) carInFront = true; } } else { if (Math.abs(pos.x - otherPos.x) < 1 && otherPos.z > pos.z) { distance = otherPos.z - pos.z; if (distance > 0 && distance < safetyDistance) carInFront = true; } } } } if (carInFront) carObj.speed = 0; const stopDistance = 6; const gridI = Math.floor((car.position.x - this.cityOffset + this.totalBlockSize) / this.totalBlockSize); const gridJ = Math.floor((car.position.z - this.cityOffset + this.totalBlockSize) / this.totalBlockSize); const light = this.trafficLights[gridI]?.[gridJ]; if (light) { const intersectionX = this.cityOffset + gridI * this.totalBlockSize - this.roadWidth; const intersectionZ = this.cityOffset + gridJ * this.totalBlockSize - this.roadWidth; if (carObj.direction === 'z' && light.state === 'EW' && Math.abs(car.position.z - intersectionZ) < stopDistance && car.position.z < intersectionZ) { carObj.speed = 0; } else if (carObj.direction === 'x' && light.state === 'NS' && Math.abs(car.position.x - intersectionX) < stopDistance && car.position.x < intersectionX) { carObj.speed = 0; } } if (carObj.direction === 'x') { car.position.x += carObj.speed; if (car.position.x > cityLimit) car.position.x = -cityLimit; } else { car.position.z += carObj.speed; if (car.position.z > cityLimit) car.position.z = -cityLimit; } }); }
    });
    </script>
</body>
</html>
